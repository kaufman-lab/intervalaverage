% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/intervalaverage_functions.R
\name{intervalaverage}
\alias{intervalaverage}
\title{time-weighted average of values measured over intervals}
\usage{
intervalaverage(
  x,
  y,
  interval_vars,
  value_vars,
  group_vars = NULL,
  required_percentage = 100,
  skip_overlap_check = FALSE,
  verbose = FALSE
)
}
\arguments{
\item{x}{a data.table containing values measured over intervals. see interval_vars parameter
for how to specify interval columns and value_vars for how to specify value columns.
intervals in x must must be completely non-overlapping within
groups defined by group_vars. if group_vars is specified (non-NULL), BOTH x and y must
contain columns specified in group_vars.}

\item{y}{a data.table object containing intervals over which you'd like averages
of x-measures computed. y intervals, unlike x intervals, may be overlapping.
if group_vars is specified (non-NULL),  y must contains those group_vars column names,
and this would allow different averaging period for each subject/monitor/location.}

\item{interval_vars}{a length-2 character vector of column names in both x and y.
these columns in x and y must all be of the same class and either be integer or IDate.}

\item{value_vars}{a character vector of column names in x. This specifies
the columns to be averaged.}

\item{group_vars}{a character vector of column names in x and in y
specifying subjects/monitors/locations within which to take averages.
can by NULL, in which case averages are taken over the entire x
dataset for each y period.}

\item{required_percentage}{the percentage of non-missing, measured x-observations in periods
defined by y for the resulting measure in the return to be nonmissing.
by default, 100 (meaning that any missing observations will result in an NA).}

\item{skip_overlap_check}{by default, FALSE. setting this to TRUE will skip
internal checks to make sure x intervals are non-overlapping within
groups defined by group_vars. #'  intervals in x must be non-overlapping,
but you may want to skip this check if you've  already checked this because
it is computationally intensive for large datasets.}

\item{verbose}{set to TRUE to include timings}
}
\value{
returns a data.table object.
Rows of the return data.table correspond to intervals from y. i.e, the number
of rows of the return will be the number of rows of y.
Columns of the returned data.table are as follows: \cr
\itemize{
\item grouping variables as specified in group_vars \cr
\item interval columns corresponding to intervals in y. columns are named the same as they were in x and y.
\item value variable columns from x, averaged to periods in y.
named the same as they were in x \cr
\item \code{yduration}: the length of the interval (ie as a count) specified in y \cr
\item \code{xduration}: the total length of the intervals (ie as a count)
from x that fall into this interval from y. this will be equal to
yduration if x is comprehensive for (ie, fully covers)  this interval from y. \cr
\item \code{nobs_<value_vars>}: for each \code{value_var} specified, this is the count of
non-missing values from x that fall into this interval from y. this will be
equal to xduration if the value_var contains no NA values over the y
interval. If there are NAs in value variables, then \code{nobs_<value_vars>}
will be different from \code{xduration} and won't necessarily be all the same
for each value_var. \cr
Rows of y where an average cannot be calculated
(either due to the measurements being present in X but NA or the measurements
not being in x at all) are still returned with value variable columns set to NA
(see the required_percentage argument for more details). \cr
\item \code{xminstart}: the minimum of the start intervals in x used in averaging returned
y intervals, within groups. If the start of the earliest x interval is less than the start
of the y interval, the minumum of the y interval is returned. Note, this is the minimum start
time whether or not value_vars were missing or not for that start time.
If you really need non-missing minimum start times, you can remove missing intervals from
x prior to calling intervalaverage (calling this separately for each value_var).
\item \code{maxend}:  the maximum of the end intervals in x used in averaging returned y intervals,
within groups. Again, like for xminstart,
this does not pay attention to whether the interval in x had non-missing value_vars.
}
}
\description{
\code{intervalaverage} is a function which takes values recorded over
non-overlapping intervals and averages them to defined intervals, possibly within
groups (individuals/monitors/locations/etc).  This function is used to average
values measured over short intervals and/or to downsample (without smoothing) values to
even shorter intervals or shift (via averaging) the data to a different schedule.
}
\details{
All intervals are treated as inclusive.

this function uses the data.table package. The input tables and return are
objects of class data.table.
data.tables are (mostly) just fancy data.frames, so if you're
unfamiliar with this package you could use \code{as.data.frame(x)},
\code{as.data.frame(y)}
as the inputs and similarly coerce the result from a data.table back to a
data.frame using \code{as.data.frame()}

x and y are not copied but rather passed by reference to function internals
to save memory in the case of very large datasets.
the data.table keys of \code{x} and \code{y} (and therefore row order) will be altered.
This is a compromise
to avoid unnecessary copying and/or unnecessary rekeying when dealing with
large x and y tables. \cr

When required_percentage is less than 100, xminstart and xmaxend may be useful to
determine whether an average meets specified coverage requirements in terms of span
(range) of the y interval.\cr
}
