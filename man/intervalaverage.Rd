% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/intervalaverage_functions.R
\name{intervalaverage}
\alias{intervalaverage}
\title{time-weighted average of values measured over intervals}
\usage{
intervalaverage(
  x,
  y,
  interval_vars,
  value_vars,
  group_vars = NULL,
  required_percentage = 100,
  skip_overlap_check = FALSE,
  verbose = FALSE
)
}
\arguments{
\item{x}{a data.table containing values measured over intervals. see interval_vars parameter
for how to specify interval columns and value_vars for how to specify value columns.
intervals in x must must be completely non-overlapping within
groups defined by group_vars. if group_vars is specified (non-NULL), BOTH x and y must
contain columns specified in group_vars.}

\item{y}{a data.table object containing intervals over which averages of x values should be computed.
averaging intervals in y unlike measurement intervals in x, may be overlapping with groups.
if group_vars is specified (non-NULL),  y must contains those group_vars column names
(and this would allow different averagings period for each group)}

\item{interval_vars}{a length-2 character vector of column names in both x and y.
these columns in x and y must all be of the same class and either be integer or IDate.}

\item{value_vars}{a character vector of column names in x. This specifies
the columns to be averaged.}

\item{group_vars}{NULL, or a character vector of column names in both x and y. Together the interaction of
these variables define groups in which averages of x values will be taken.
specifying subjects/monitors/locations within which to take averages.
can by NULL, in which case averages are taken over the entire x
dataset for each y period.}

\item{required_percentage}{What percentage of the duration of the y interval should x be observed
and nonmissing for in order for the return table to contain a nonmissing value for that average?
The default is 100 meaning that for an interval in y, any amount of missing or non-present
measurement days in x will result in a value of NA for that average.}

\item{skip_overlap_check}{by default, FALSE. setting this to TRUE will skip
internal checks to make sure x intervals are non-overlapping within
groups defined by group_vars. #'  intervals in x must be non-overlapping,
but you may want to skip this check if you've  already checked this because
it is computationally intensive for large datasets.}

\item{verbose}{include printed timing information? by default, FALSE}
}
\value{
returns a data.table object.
Rows of the return data.table correspond to intervals from y. i.e, the number
of rows of the return will be the number of rows of y.
Columns of the returned data.table are as follows: \cr
\itemize{
\item grouping variables as specified in group_vars \cr
\item interval columns corresponding to intervals in y. columns are named the same as they were in x and y.
\item value variable columns from x, averaged to periods in y.
named the same as they were in x \cr
\item \code{yduration}: the length of the interval (ie as a count) specified in y \cr
\item \code{xduration}: the total length of the intervals (ie as a count)
from x that fall into this interval from y. this will be equal to
yduration if x is comprehensive for (ie, fully covers)  this interval from y. \cr
\item \code{nobs_<value_vars>}: for each \code{value_var} specified, this is the count of
non-missing values from x that fall into this interval from y. this will be
equal to xduration if the value_var contains no NA values over the y
interval. If there are NAs in value variables, then \code{nobs_<value_vars>}
will be different from \code{xduration} and won't necessarily be all the same
for each value_var.
\item \code{xminstart}: For each returned interval (ie the intervals from Y) the minimum of the
start intervals represented in x.  If the start of the earliest x interval is less than the start
of the y interval, the minumum of the y interval is returned. Note, this is the minimum start
time in x matching with the y interval whether or not any value_vars were missing or not for that start time.
If you need non-missing minimum start times, you could remove NA intervals from
x prior to calling intervalaverage (this would need to be done separately for each value_var).
\item \code{xmaxend}:  similar to xminstart but the maximum of the end inetervals represented in x.
Again, this does not pay attention to whether the interval in x had non-missing value_vars.
}
}
\description{
\code{intervalaverage} takes values recorded over
non-overlapping intervals and averages them to defined intervals, possibly within
groups (individuals/monitors/locations/etc).  This function could be used to take averages over long
intervals
of values measured over short intervals and/or to take short "averages" of values measured over
longer intervals (ie, downsample without smoothing). Measurement intervals and averaging intervals need
not align. In the event that an averaging interval contains more than one measurement interval,
a weighted average is calculated (ie each measurement is weighted on the duration of its interval's
overlap with the averaging period interval).
}
\details{
All intervals are treated as closed (ie inclusive of the start and end values in interval_vars)

x and y are not copied but rather passed by reference to function internals
but the order of these data.tables is restored on function completion or error,

When required_percentage is less than 100, xminstart and xmaxend may be useful to
determine whether an average meets specified coverage requirements in terms of not
just percent of missingness but whether values are represented through the range of the y interval
}
\examples{
x <- data.table(start=seq(1L,by=7L,length=6),
               end=seq(7L,by=7L,length=6),
               pm25=c(10,12,8,14,22,18))

y <- data.table(start=seq(3L,by=7L,length=6),
               end=seq(9L,by=7L,length=6))

z <- intervalaverage(x,y,interval_vars=c("start","end"),
                    value_vars=c("pm25"))

#also see vignette for more extensive examples
}
