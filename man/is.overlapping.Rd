% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/isoverlapping.R
\name{is.overlapping}
\alias{is.overlapping}
\alias{is.overlappingv}
\title{Test for self-overlap in a data.table or a pair of vectors}
\usage{
is.overlapping(x, interval_vars, group_vars = NULL, verbose = FALSE)

is.overlappingv(start, end)
}
\arguments{
\item{x}{A data.table with two columns defining closed intervals (see also interval_vars).}

\item{interval_vars}{A length-2 character vector corresponding to column names of x which designate
the closed (inclusive) starting and ending intervals. The column name
specifying the lower-bound column must be specified first.
these columns be of the same class and either be integer or IDate.}

\item{group_vars}{NULL or a character vector corresponding to column names of x.
overlap checks will occur within groups defined by the columns specified here.}

\item{verbose}{prints additional information, default is FALSE}

\item{start}{An integer vector (including vectors of class IDate) defining the closed starts of a set of intervals.}

\item{end}{An integer vector (including vectors of class IDate) defining the closed ends of a set of intervals.}
}
\value{
length-1 logical vector. TRUE if there are any overlaps, FALSE otherwise.
(note that a single pair of overlapping intervals within a single group specified by group_vars
will result in TRUE)

length-1 logical vector. TRUE if there are any overlaps, FALSE otherwise.
}
\description{
\code{is.overlapping} tests whether a data.table contains intervals which partially or completely overlap
with other intervals in different rows, possibly within groups. \code{is.overlappingv} tests whether
intervals defined by a pair of vectors contains intervals which partially or completely overlap.
}
\details{
These functions provide a fast check to see if any intervals in a set overlap.
To actually identify specific segments of overlap,
the \code{data.table::foverlap} can be use to return self-join for partial and/or exactly overlapping
intervals.

\code{intervalaverage::isolateoverlaps} can be used to break partially overlapping intervals
into separate intervals of exact overlap and non-overlap.

Note that it's also possible to use \code{data.table::foverlap} directly to test the
existence of overlaps in a set of intervals
(in fact, that's a what \code{is.overlapping} did in version 0.8.0 and before).
However, this performs a join and if there are many overlaps then \code{foverlaps}
will join them all--this is unnecessarily slow and memory intensive if the goal
is to just test for the existence of one or more overlap.
}
\examples{
x <- data.table(start=c(1L,2L),end=c(3L,4L))
is.overlapping(x,c("start","end")) #the interval 1,3 overlaps with the interval 2,4

#or, using the raw vectors:
is.overlappingv(x$start,x$end)

y <- data.table(start=c(1L,3L),end=c(2L,4L))
is.overlapping(y,c("start","end")) #the interval 1,2 doesn't overlap other intervals in y
z <- data.table(start=c(1L,3L,1L,2L),end=c(2L,4L,3L,4L),id=c(1,1,2,2))
is.overlapping(z,c("start","end"),"id")

#note the above returns TRUE because there is an overlap in the group defined by z$id==2
#to identify which group(s) are overlapping:

setkey(z, id, start,end)
z[,key(.SD),by="id"]
z[,is.overlappingv(start,end),by="id"]


}
